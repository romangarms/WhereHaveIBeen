{% extends "layout.html" %}

{%block title %}
<title>WhereHaveIBeen Map</title>
{%endblock%}

{% block main %}


<!-- Get OwnTracks server info so we can read data from it -->
<div id="map-container">
    <div class="form-popup" id="myForm">
        <form action="/login" method="POST">

            <h3>Enter OwnTrack Login and URL</h3>

            <input type='text' placeholder='username' name='username' autocomplete="on" />
            <input type='password' placeholder='password' name='password' autocomplete="on" />
            <input type='serverurl' placeholder='https://[your domain]' name='serverurl' autocomplete="on" /></p>
            <input class="btn btn-success" type='submit' value='Login' />
        </form>
    </div>

    <div id="map"></div>



    <div id="map-shadow"></div>
</div>
<script>
    //debuggingTest();

    var latlngs;
    // Initialize the map
    var map = L.map('map').setView([37.7749, -122.4194], 13);

    // Add a tile layer
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    // Track if we're using cached data for this load
    let usingCache = false;

    // Track if user has applied a custom time filter this session
    let customTimeFilterApplied = false;

    /**
     * Check if the current query is an "all time" query (eligible for caching)
     * Caching only optimizes all-time queries, not custom date ranges
     */
    function isAllTimeQuery() {
        // If user explicitly applied a time filter, it's not an all-time query
        if (customTimeFilterApplied) {
            return false;
        }

        // If this is the initial default values, it's an all-time query
        const startBox = document.getElementById('startBox');
        const endBox = document.getElementById('endBox');

        if (startBox.value === '2015-01-01T00:00' && endBox.value === '2099-12-31T23:59') {
            return true;
        }

        // Otherwise, the dates were set automatically by fetchLocations on first load
        // which means it's the full data range (all-time)
        return true;
    }

    /**
     * Mark that user has applied a custom time filter
     */
    function setCustomTimeFilter() {
        customTimeFilterApplied = true;
    }

    /**
     * Reset the custom time filter flag and reload all-time data
     */
    function loadAllTimeData() {
        customTimeFilterApplied = false;
        // Reset to defaults - fetchLocations will set actual data range
        document.getElementById('startBox').value = '2015-01-01T00:00';
        document.getElementById('endBox').value = '2099-12-31T23:59';
        firstLoad = true; // Reset so dates get auto-populated
        resetMap();
    }

    /**
     * Get current settings for cache validation
     */
    function getCurrentSettings() {
        return {
            bufferSize: parseFloat(document.getElementById('circleSize').value) || 0.5,
            osrmUrl: document.getElementById('osrmURL').value || ''
        };
    }

    async function runTasks() {
        const user = document.getElementById('userBox').value;
        const device = document.getElementById('deviceBox').value;

        // Initialize IndexedDB
        try {
            await initDB();
        } catch (err) {
            console.log("IndexedDB not available, proceeding without cache:", err);
        }

        // Check for valid cache
        let cacheData = null;
        let cacheValid = false;
        const currentSettings = getCurrentSettings();

        if (isAllTimeQuery()) {
            try {
                cacheData = await getCache(user, device);
                if (cacheData) {
                    // Validate cache data structure first
                    if (!validateCacheData(cacheData)) {
                        console.log("Cache data corrupted, clearing and recalculating");
                        await clearCache(user, device);
                        cacheData = null;
                    } else {
                        // Then validate settings match
                        cacheValid = validateCacheSettings(
                            cacheData.settings,
                            currentSettings.bufferSize,
                            currentSettings.osrmUrl
                        );

                        if (!cacheValid) {
                            console.log("Cache invalidated due to settings change");
                            cacheData = null;
                        }
                    }
                }
            } catch (err) {
                console.error("Error checking cache:", err);
                cacheData = null;
            }
        }

        if (cacheData && cacheValid) {
            await runTasksWithCache(cacheData, user, device, currentSettings);
        } else {
            await runTasksFresh(user, device, currentSettings);
        }
    }

    /**
     * Run tasks using cached data - only fetch and calculate new data since cache timestamp
     */
    async function runTasksWithCache(cacheData, user, device, currentSettings) {
        usingCache = true;
        console.log("Using cached data, fetching only new data");

        // Determine the latest timestamp from cache
        const cacheTimestamp = cacheData.driving?.timestamp || cacheData.flying?.timestamp;
        if (!cacheTimestamp) {
            console.log("No valid timestamp in cache, falling back to fresh load");
            return runTasksFresh(user, device, currentSettings);
        }

        // Set initial progress bar steps (fewer for cached load)
        setProgressBarNumSteps(5);

        // Check if logged in
        const loggedIn = await checkIfLoggedIn();

        if (!loggedIn) {
            openForm();
            return;
        }

        closeForm();
        setProgressMessage("Loading from cache...");
        completeTask("loading from cache", 0);
        updateProgressBar();

        // Immediately render cached buffers with corruption handling
        try {
            if (cacheData.driving?.buffer) {
                renderCachedBuffer(cacheData.driving.buffer, "blue");
                getBufferStats(cacheData.driving.buffer);
            }
            if (cacheData.flying?.buffer) {
                renderCachedBuffer(cacheData.flying.buffer, "red");
            }
        } catch (err) {
            console.error("Cache corruption detected, falling back to fresh load:", err);
            setProgressMessage("Cache error - recalculating...");
            // Clear corrupted cache
            try {
                await clearCache(user, device);
            } catch (clearErr) {
                console.error("Failed to clear corrupted cache:", clearErr);
            }
            return runTasksFresh(user, device, currentSettings);
        }

        // Fetch only new data since cache timestamp
        // Add 1 second to avoid duplicate of last point
        const cacheDate = new Date(cacheTimestamp);
        cacheDate.setSeconds(cacheDate.getSeconds() + 1);
        const newStartDate = cacheDate.toISOString();

        setProgressMessage("Fetching new data...");
        const newData = await fetchLocations({
            startDate: newStartDate,
            taskName: "fetching new data"
        });

        // Check if there's new data to process
        if (!newData || newData.isEmpty || !newData.features || newData.features.length === 0) {
            console.log("No new data since cache, using cached buffers only");
            setProgressMessage("Complete - loaded from cache");
            completeTask("no new data", 0);
            updateCacheStatusUI(cacheData, user, device);
            return;
        }

        // Filter and process new data
        setProgressMessage("Processing new data...");
        const { drivingLatlngs, flyingLatlngs } = await filterData(newData);
        updateProgressBar();

        // Get stats for new data
        getOwntracksStats(newData);

        // Calculate new segments
        let extraTasks = 0;
        if (drivingLatlngs.length > 0) extraTasks++;
        if (flyingLatlngs.length > 0) extraTasks++;

        let totalNumSegments = drivingLatlngs.length * 3 + flyingLatlngs.length * 3;
        setProgressBarNumSteps(totalNumSegments + getNumTasksDone() + extraTasks + 1);

        // Clear the map to redraw merged buffers
        eraseLayers();
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        // Calculate and merge buffers
        let newDrivingBuffer = null;
        let newFlyingBuffer = null;
        let finalDrivingBuffer = cacheData.driving?.buffer || null;
        let finalFlyingBuffer = cacheData.flying?.buffer || null;

        setProgressMessage("Merging with cache...");
        if (drivingLatlngs.length > 0) {
            newDrivingBuffer = await calculateAndDrawRoute(newData, drivingLatlngs, "blue", {
                cachedBuffer: cacheData.driving?.buffer
            });
            finalDrivingBuffer = newDrivingBuffer;
        } else if (cacheData.driving?.buffer) {
            renderCachedBuffer(cacheData.driving.buffer, "blue");
        }

        if (flyingLatlngs.length > 0) {
            newFlyingBuffer = await calculateAndDrawRoute(newData, flyingLatlngs, "red", {
                cachedBuffer: cacheData.flying?.buffer
            });
            finalFlyingBuffer = newFlyingBuffer;
        } else if (cacheData.flying?.buffer) {
            renderCachedBuffer(cacheData.flying.buffer, "red");
        }

        // Update cache with merged data
        setProgressMessage("Saving cache...");
        const latestTimestamp = getLatestTimestamp(newData);
        const newCacheData = {
            driving: {
                buffer: finalDrivingBuffer,
                timestamp: latestTimestamp || cacheData.driving?.timestamp,
                startTimestamp: cacheData.driving?.startTimestamp
            },
            flying: {
                buffer: finalFlyingBuffer,
                timestamp: latestTimestamp || cacheData.flying?.timestamp,
                startTimestamp: cacheData.flying?.startTimestamp
            },
            settings: currentSettings
        };

        try {
            await setCache(user, device, newCacheData);
            completeTask("cache updated", 0);
        } catch (err) {
            console.error("Failed to update cache:", err);
        }

        setProgressMessage("Complete");
        updateCacheStatusUI(newCacheData, user, device);
    }

    /**
     * Run tasks from scratch - no cache available or cache invalid
     */
    async function runTasksFresh(user, device, currentSettings) {
        usingCache = false;
        console.log("Running fresh calculation (no cache)");

        // how many steps to progress bar
        setProgressBarNumSteps(7);

        // check if logged in
        const loggedIn = await checkIfLoggedIn();

        if (loggedIn) {
            closeForm();
            updateProgressBar();

            // locations
            setProgressMessage("Fetching location data...");
            const data = await fetchLocations();

            if (!data || data.isEmpty) {
                console.log("No data available");
                setProgressMessage("No data available");
                return;
            }

            updateProgressBar();

            // filter data
            setProgressMessage("Processing data...");
            const { drivingLatlngs, flyingLatlngs } = await filterData(data)
            updateProgressBar();

            // get owntracks stats
            getOwntracksStats(data);

            // extra buffer stats for each type of data, driving/flying
            let extraTasks = 0;
            if (drivingLatlngs.length > 0) {
                extraTasks++;
            }
            if (flyingLatlngs.length > 0) {
                extraTasks++;
            }

            let totalNumSegments = drivingLatlngs.length * 3 + flyingLatlngs.length * 3;
            setProgressBarNumSteps(totalNumSegments + getNumTasksDone() + extraTasks + 1);

            let drivingBuffer = null;
            let flyingBuffer = null;

            setProgressMessage("Calculating routes...");
            if (drivingLatlngs.length > 0) {
                drivingBuffer = await calculateAndDrawRoute(data, drivingLatlngs, "blue");
            }

            if (flyingLatlngs.length > 0) {
                flyingBuffer = await calculateAndDrawRoute(data, flyingLatlngs, "red");
            }

            // Save to cache if this is an all-time query
            if (isAllTimeQuery()) {
                setProgressMessage("Saving cache...");
                const earliestTimestamp = getEarliestTimestamp(data);
                const latestTimestamp = getLatestTimestamp(data);

                const cacheData = {
                    driving: {
                        buffer: drivingBuffer,
                        timestamp: latestTimestamp,
                        startTimestamp: earliestTimestamp
                    },
                    flying: {
                        buffer: flyingBuffer,
                        timestamp: latestTimestamp,
                        startTimestamp: earliestTimestamp
                    },
                    settings: currentSettings
                };

                try {
                    await setCache(user, device, cacheData);
                    completeTask("cache saved", 0);
                    console.log("Buffer cache saved successfully");
                } catch (err) {
                    console.error("Failed to save cache:", err);
                }

                updateCacheStatusUI(cacheData, user, device);
            }

            setProgressMessage("Complete");
        } else {
            openForm();
        }
    }

    /**
     * Update the cache status display in the UI
     */
    async function updateCacheStatusUI(cacheData, user, device) {
        const cacheStatusEl = document.getElementById('cacheStatus');
        if (!cacheStatusEl) return;

        try {
            const dateRange = getCacheDateRange(cacheData);
            const cacheSize = await getCacheSize(user, device);

            if (dateRange) {
                document.getElementById('cacheDateRange').textContent =
                    formatCacheDate(dateRange.startDate) + ' - ' + formatCacheDate(dateRange.endDate);
            } else {
                document.getElementById('cacheDateRange').textContent = 'No cached data';
            }

            document.getElementById('cacheSize').textContent = formatBytes(cacheSize);
            cacheStatusEl.style.display = 'block';
        } catch (err) {
            console.error("Error updating cache status UI:", err);
        }
    }

    /**
     * Clear cache for current user/device
     */
    async function clearCurrentCache() {
        const user = document.getElementById('userBox').value;
        const device = document.getElementById('deviceBox').value;

        if (confirm('Clear cached data for ' + user + '/' + device + '? This will recalculate all routes on next load.')) {
            try {
                await clearCache(user, device);
                console.log("Cache cleared");
                document.getElementById('cacheDateRange').textContent = 'No cached data';
                document.getElementById('cacheSize').textContent = '0 Bytes';
                resetMap();
            } catch (err) {
                console.error("Error clearing cache:", err);
            }
        }
    }

    // run on page load
    window.onload = function () {

        // load user settings
        getUserSettings();

        // find users and devices, then calculate route for the first entry
        getUsersAndDevices().then(usersAndDevices => {

            // if no users, not logged in
            if (usersAndDevices != -1) {
                runTasks();
            }
        });
    };


</script>


<div id="progressBar">
    <div id="progressBarInner"></div>
    <span id="progressBarMessage"></span>
</div>


<div id="infoBox">

    <div id="leftPanel">
        <!-- MAP CONTROLS -->

        <div class="innerPanel">
            <div class="titlePanel">
                <h1> Filters </h1>
                <p class="settingInfo">Is your data showing incorrectly on the map? Try adjusting these settings. Make
                    sure
                    the user and device are correct, and try changing time frame.</p>

            </div>

            <div class="subPanel">
                <h4>Choose a user and device</h4>
                <p class="settingInfo">Choose which device to track. This is your OwnTracks user and device.</p>


                <select class="form-select" id="userBox">
                    <option value="" selected disabled>Choose a user</option>
                </select>
                <select class="form-select" id="deviceBox">
                    <option value="" selected disabled>Choose a device</option>
                </select>
            </div>


            <div class="subPanel">
                <h4>Time frame</h4>
                <p class="settingInfo">Filter the map to only shows GPS data between these two dates. Time is in UTC.
                </p>
                <div class="dateFilters" style="float:left; width: 50%;">
                    <h5>Start Date </h5>

                    <input type="datetime-local" class="input-group date" id="startBox" onkeyup="" name="trip-start"
                        value="2015-01-01T00:00" min="2015-01-01T00:00" max="2099-12-31T23:59" />
                </div>
                <div class="dateFilters" style="float:left; width: 50%;">
                    <h5>End Date </h5>
                    <input type="datetime-local" class="input-group date" id="endBox" onkeyup="" name="trip-start"
                        value="2099-12-31T23:59" min="2015-01-01T00:00" max="2099-12-31T23:59" />
                </div>

                <input type="button" class="btn btn-primary time-period-btn" value="Last Month"
                    onclick="changeDateRange('month')" />
                <input type="button" class="btn btn-primary time-period-btn" value="Last Week"
                    onclick="changeDateRange('week')" />
                <input type="button" class="btn btn-primary time-period-btn" value="Last 48 Hours"
                    onclick="changeDateRange('48hrs')" />
                <input type="button" class="btn btn-primary time-period-btn" value="Last 24 Hours"
                    onclick="changeDateRange('24hrs')" />
                <input type="button" class="btn btn-success time-period-btn" value="All Time"
                    onclick="loadAllTimeData()" />

            </div>
            <div class="subPanel">
                <h4>Apply Filters</h4>
                <input type="button" class="btn btn-primary" value="Apply" onclick="setCustomTimeFilter(); resetMap(map)" />
            </div>
        </div>

        <div class="innerPanel">
            <div class="titlePanel">
                <h1>Settings</h1>
            </div>

            <div class="subPanel">
                <h4>Map Settings</h4>
                <p class="settingInfo">Adjust settings about the way the routes and blue area buffer are drawn on the
                    map.</p>
                <h5>Hide Route <span class="info-icon">i
                        <span class="tooltip-text">The route is only drawn when less than 500 GPS
                            points are used. Adjust the date filters to see this!</span>
                    </span></h5>
                <input type="button" class="btn btn-danger" value="Remove Route" onclick="eraseRoute(map)" />

                <h5>Buffer Size <span class="info-icon">i
                        <span class="tooltip-text">Change how large of a buffer is drawn around your route in
                            kilometers.
                            Note that larger values take longer to draw. Changing this will invalidate your cache.</span>
                    </span></h5>

                <p class="settingInfo">Default: 0.5km</p>
                <input type="number" class="form-control form-control-lg" id="circleSize" value="0.5" step="0.1"
                    min="0.1" max="10" />
            </div>

            <div class="subPanel">
                <h4>Routing Settings</h4>
                <p class="settingInfo">Change the URL of the routing engine if you host your own or want to use the
                    public OSRM one.</p>
                <h5>Custom OSRM Router <span class="info-icon">i
                        <span class="tooltip-text">Change the URL used for the OSRM router. Changing this will invalidate your cache.</span>
                    </span></h5>

                <p class="settingInfo">Default: leave blank</p>
                <input type="url" class="form-control form-control-lg" id="osrmURL" value="" />
            </div>

            <div class="subPanel" id="cacheStatus" style="display: none;">
                <h4>Cache <span class="info-icon">i
                        <span class="tooltip-text">Cached buffer polygons speed up loading on return visits. Only new GPS data since your last visit needs to be processed.</span>
                    </span></h4>
                <p class="settingInfo">
                    <strong>Cached:</strong> <span id="cacheDateRange">No cached data</span><br>
                    <strong>Storage:</strong> <span id="cacheSize">0 Bytes</span>
                </p>
                <input type="button" class="btn btn-warning" value="Clear Cache" onclick="clearCurrentCache()" />
            </div>

            <div class="subPanel">
                <h4>Save and Apply Settings</h4>
                <input type="button" class="btn btn-primary" value="Apply" id="applySettingsButton"
                    onclick="resetMap(map)" />
            </div>
        </div>
    </div>
    <div id="rightPanel">
        <!-- MAP INFO -->
        <div class="titlePanel">
            <h1 id="title">Information </h1>
            <p> This map shows the location history of the devices that are sending their location data to the Owntracks
                server. <a href="/about">Learn more.</a>
            </p>
        </div>

        <div class="subPanel">
            <h4>Total distance travelled <span class="info-icon">i
                    <span class="tooltip-text">Note! This can be quite inaccurate over a large date range as there are
                        some
                        shortcuts in this calculation.</span>
                </span> </h4>
            <div id="totalDist"> </div>

            <h4>Area explored is </h4>
            <div id="totalArea"></div>

            <h4>Percentage of west coast covered <span class="info-icon">i
                    <span class="tooltip-text">Calculated by dividing your area explored by 863,428km, the area of
                        Washington, Oregon, and California.</span>
                </span> </h4>
            <div id="totalAreaPct"></div>

            <h4>Highest Altitude</h4>
            <div id="highestAltitude"></div>

            <h4>Highest Velocity</h4>
            <div id="highestVelocity"></div>
        </div>
    </div>
</div>


{% endblock %}

{% block scripts %}

<script>
    document.getElementById('applySettingsButton').addEventListener('click', function () {
        fetch('/save_settings', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                circleSize: document.getElementById('circleSize').value,
                osrmURL: document.getElementById('osrmURL').value
            })
        })
            .then(response => response.json())
            .then(data => {
                console.log('Settings saved:', data);
            })
            .catch((error) => {
                console.error('Error:', error);
            });
    });

</script>

{% endblock %}